**设计哲学**

1. 内存安全
2. 零成本抽象
3. 实用性



**内存访问错误**

1. 引用空指针
2. 使用未初始化内存
3. 释放后使用: 悬垂指针
4. 缓冲区溢出
5. 重复释放



**零成本抽象**

1. 尽可能少的 overhead
2. 抽象代码在编译期展开, 避免运行时为解释抽象产生的开销



**Copy Trait**

该类型可以直接按 bit 进行复制

区分值语义和引用语义

实现了 Copy trait 的对象在赋值时直接拷贝原始数据, 不发生所有权转移



**作用域**

词法作用域, 由一对花括号来开辟作用域

变量的生命周期在词法作用域范围内.



**NLL**

非词法作用域生命周期, 用于更智能的判定变量生存周期, 减少编写代码时的心智负担.



**闭包的实现**

匿名结构体和 trait 组合.



**闭包和函数的区别**

闭包可以捕获外部变量



**trait**

trait 是 rust 中唯一的接口抽象方式

基于组合优于继承和面向接口编程的思想

用法:

1. 接口抽象
2. 泛型约束
3. 抽象类型
4. 标签 trait



**trait 的静态分发和动态分发**

对于类型 `&T`  , `Box<dyn T>` 这样的类型, 动态分发

差别: 编译器是否可以推断将被使用的真实类型



**孤儿规则**

类型或 Trait 至少有一个是本地定义的



**重叠规则**

不能为重叠的类型实现同一个 trait.

影响了代码复用.



**特化**

前提: 

1. 默认实现(trait 定义内实现, 或在 impl 中用 default 标记)
2. 对具体类型采用其他实现



**rust 的指针**

1. 引用: &T, &mut T
2. 原生指针: *const T, *mut T



- 引用和原生指针可以用过 as 转换.
- 原生指针可以在 unsafe 块下任意使用
- 引用必须受到编译器安全检查规则限制



**智能指针**

1. 对指针的一层封装
2. 实现了 Deref 和 Drop



**确定性析构**

RAII



**复制语义和移动语义**

Copy 对应值语义

Move 对应引用语义



**所有者的权限**

1. 控制资源释放
2. 出借所有权
3. 转移所有权



**Send**

该类型的实例可以在线程间安全传递所有权



**Sync**

该类型的实例可以安全地跨线程共享



**宏的种类**

按定义方式:

1. 声明宏: 通过 macro_rules ! 声明
2. 过程宏: 实现自定义派生属性



按使用的语法形式:

1. 调用宏
2. 属性宏



按来源:

1. 内置宏
2. 自定义宏



**声明宏中可捕获的类型**

1. item 语言项
2. block 代码块
3. stmt 语句
4. expr 表达式
5. pat 模式
6. ty 类型
7. ident 标识符
8. path 路径
9. meta 元信息
10. tt 词条树
11. vis 可见性
12. lifetime 生命周期参数



**Unsafe Rust 不提供安全检查的情形**

1. 解引用裸指针
2. 调用 unsafe 的函数或方法
3. 访问或修改可变静态变量
4. 实现 unsafe trait
5. 读写 Union 联合体中的字段



**Union**

- Enum 属于 Tagged Union, 内部的 tag 可以保证内存安全
- Union 没有 tag, 需要靠程序逻辑来保证安全性



**FFI**

外部函数接口, 用于规范语言间调用的语言特性

对不同语言的语义和调用约定进行匹配



**ABI**

应用程序二进制接口

涵盖:

1. 调用约定
2. 内存布局
3. 处理器指令集
4. 目标文件和库的二进制格式



**extern**

1. 关键字: 的函数可以在 Rust 和 C 语言中自由使用
2. 块: 将外部的 C 函数逐个标记, 供 Rust 内部使用



extern "Rust":  默认的 ABI

extern "C": 指定使用 C-ABI

extern "system": 类似 C, 但在 Win32平台上等价于 stdcall



rust-bindgen: .h => .rs

cbindgen: .rs => .h



**no_mangle**

关闭函数名称修改