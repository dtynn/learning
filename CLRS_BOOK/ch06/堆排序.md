### Ch06 堆排序

#### 6.1 堆

堆是一个近似的完全二叉树.

除了最底层之外, 每一层都是满的

```
LEFT(i) = 2i + 1

RIGHT(i) = 2i + 2

PARENT(i) = (i-1) / 2
```

- 最大堆: 除了根以外, 对所有节点 i 都满足 i 的父节点大于等于 i 节点
- 最小堆: 除了根以外, 对所有节点 i 都满足 i 的父节点小于等于 i 节点



#### 6.2 维护堆的性质

`MAX-HEAPIFY(A, i)` 

1. 首先假设 i 的左右子树都满足最大堆性质
2. 维护 i 及 LEFT(i), RIGHT(i) 使之满足最大堆性质
3. 如果在 2 中发生了节点对换, 则对以 "发生了对换的节点" 为根节点的子树重新维护最大堆性质

MAX-HEAPIFY 的运行时间 $T(n) = T(2n/3) + \Theta(1) = \Theta(\lg n)$



#### 6.3 建堆

`BUILD-MAX-HEAP(A)`

由堆的性质可知, 节点 [len(A)/2 : len(A)] 都是叶子节点, 对 [: len(A)/2] 自底向上循环迭代维护最大堆性质, 则可以建立一个最大堆

时间复杂度是 $O(n)$ 即线性时间



#### 6.4 堆排序算法

1. BUILD-MAX-HEAP 将数组构成最大堆
2. 将第一个元素与最后一个元素对调, 排除最后一个元素构成新的堆
3. 针对根节点维护堆性质
4. 反复执行 2-3 直到所有元素都被抽出构成一个已经排好序的数组

堆排序的时间复杂度是 $O(n\lg n)$



#### 6.5 优先队列

用来维护一组有先后顺序的元素的数据结构

常见使用场景:

- 任务调度, 最大优先队列, 使用优先级为关键字
- 时间驱动, 最小优先队列, 使用时间戳为关键字



对于最大优先队列, 支持

- INSERT(S, x)
- MAXIMUM(S)
- EXTRACT-MAX(S)
- INCREASE-KEY(S, x, k)



