### Ch10 基本数据结构

#### 10.1 栈和队列

栈实现的是后进先出 (LIFO) 策略.

队列实现的是先进先出 (FIFO 策略.



##### 栈

- PUSH
- POP

对空栈执行 POP, 称为栈下溢(underflow)

对满栈执行 PUSH , 称为上溢(overflow)

##### 队列

- ENQUEUE
- DEQUEUE



#### 10.2 链表

链表中各个对象按线性顺序排列, 顺序由各个对象里的指针决定.

##### 双向链表

对象包含关键字 key, 和指向前驱元素 (prev) 和后继元素 (next) 的指针, 以及可能的附加数据.



##### 链表形式:

- 单链接 - 双链接

  单链接: 忽略 prev 指针

- 已排序 - 未排序

  已排序: 链表顺序即对象的关键字顺序

- 循环 - 非循环

  循环: 表头元素 prev 指向表尾元素, 表尾元素 next 指向表头元素

  ​

##### 链表操作

- SEARCH(k)
- INSERT(x)
- DELETE(x)

##### 哨兵

哨兵是逻辑上为 nil 的一个对象.

哨兵的 prev 指向表头, next 指向表尾, 从而构成一个双向循环链表.

哨兵的用途是简化代码, 降低常数因子, 但是会有额外的空间占用.



#### 10.3 指针和对象的实现

##### 对象的多数组表示

1. 用等长的三个数组分别存储对象的 key, next, prev
2. 用一个额外的变量存放表头元素的下标



##### 对象的单数组表示

1. 用连续的子数组来存储对象的 key, next, prev
2. 用一个额外的变量存放表头元素的下标



##### 对象的分配与释放

1. 将未使用的对象放在一个单链表中, 即自由表(free list)
2. 用一个额外的变量存放表头元素
3. 每次分配时, 取用表头元素, 因此自由表的表现形似栈



#### 10.4 有根树的表示

树的节点用对象表示, 假设每个节点都有关键字 k



##### 二叉树

节点的 p, left, right 分别指向父节点, 左子节点, 右子节点



##### 分支无限制的有根树

节点的 p, left-child, right-sibling 分别指向父节点, 最左侧的子节点, 右侧的同级节点

