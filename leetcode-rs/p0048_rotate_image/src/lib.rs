struct Solution {}

// 考虑一个 n = 5 的矩阵
//  [ 1, 2, 3, 4, 5]
//  [ 6, 7, 8, 9,10]
//  [11,12,13,14,15]
//  [16,17,18,19,20]
//  [21,22,23,24,25]
// 1. 令 r(ound) = [0, n), 将 (r, r+1) -> (r, n-1) 与 (r+1, r) -> (n-1, r) 逐个交换
//  [ 1, 2, 3, 4, 5]  [ 1, 6,11,16,21]
//  [ 6, 7, 8, 9,10]  [ 2, 7,12,17,22]
//  [11,12,13,14,15]=>[ 3, 8,13,18,23]
//  [16,17,18,19,20]  [ 4, 9,14,19,24]
//  [21,22,23,24,25]  [ 5,10,15,20,25]
//
// 2. 对每一行, 延中心线对称交换
//  [ 1, 6,11,16,21]  [21,16,11, 6, 1]
//  [ 2, 7,12,17,22]  [22,17,12, 7, 2]
//  [ 3, 8,13,18,23]  [23,18,13, 8, 3]
//  [ 4, 9,14,19,24]  [24,19,14, 9, 4]
//  [ 5,10,15,20,25]  [25,20,15,10, 5]
//
impl Solution {
    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {
        let n = matrix.len();
        for r in 0..n {
            let mut row = r + 1;
            while row < n {
                matrix[row][r] = matrix[row][r] ^ matrix[r][row];
                matrix[r][row] = matrix[row][r] ^ matrix[r][row];
                matrix[row][r] = matrix[row][r] ^ matrix[r][row];
                row += 1;
            }
        }

        for row in 0..n {
            matrix[row].reverse()
        }
    }
}
