## 字符串匹配基础

### BF 算法 (Brute Force)

- 暴力匹配 / 朴素匹配

- 主串 长度为 n; 模式串 长度为 m; 在主串中查找模式串.
- 最坏情况的时间复杂度是 O(n*m)
- 实际开发中比较常用
  - 统计意义上, 算法执行效率比 O(n*m) 高很多
  - 简单, 直观



### RK 算法 (Rabin-Karp)

- 将每次逐个比较字符, 转化成串的 hash 值对比, 既提高比对效率

- 利用合适的 hash 算法, 提高子串哈希计算的效率

  一种思路

  - 假设字符集的字符个数为 K (例: a-z, 26)
  - 使用 K 进制数表示一个子串, 转化成十进制数作为 hash 值
  - 相邻子串有交集, 可以用前一个子串值快速计算出下一个子串值
    - 假设主串为 s, 两个相邻子串为 s[i..j] 和 s[i+1..j+1]
    - 令 H(s[i..j]) 表示子串 s[i..j]的 hash 值, h(s[i]) 表示 字符 i 的 K 进制值
    - 则 $H(s[i+1..j+1]) = H(s[i..j]) - 26^{m-1} * h(s[i]) + 26^0 * h(s[j])$
    - 26^(m-1) 可以预先计算并缓存下来

- 时间复杂度是

  - 没有 hash 冲突的情况下, O(n)
  - 允许冲突的情况下, 最坏情况存在大量冲突,  O(n*m). 一般不会有很多冲突.



### BM 算法 (Boyer-Moore)

#### 核心思想

寻找某种规律, 使模式串与主串匹配过程中, 当某个字符不匹配的时候, 跳过一些肯定不匹配的情况, 将模式串多向后滑动几位.



#### 原理分析

1. 坏字符规则 (bad character rule)

   - 从模式串的末尾往前倒着匹配, 当主串中的某个字符没法匹配的时候, 将这个字符称作坏字符, 与其对应的模式串中的字符下标记做 $P_i$
   - 在模式串中, 向前搜索坏字符, 将匹配到的字符下标记做 $P_j$; 如果模式串中不存在坏字符, 则$P_j = -1$. 
   - 则 $P_i - P_j$ 就是模式串向后移动的位数.
   - 最好情况下, 时间复杂度 为  O(n/m), 在匹配具有类似特点的模式串和子串时, 非常高效

2. 好后缀规则 (good suffix shift)

   - 基本思想: 对于已经主串中匹配好了的后缀{u}, 在模式串中查找, 如果找到另一个匹配的子串{u'}, 将模式串滑动到 {u'} 与 {u} 对齐的位置; 否则将模式串滑动到 {u} 的后面

   - 上一条中的滑动方法有可能错过匹配, 例:

     主串: abcacabcbcbacabc

     模式:       cbacabc

     滑动:                     cbacabc

   - 将模式串向后滑动的过程中:

     - 如果 {u} 与模式串重合, 肯定无法完全匹配
     - 如果 {u} 的后缀 与模式串的某个前缀部分重合且重合部分相等时, 有可能匹配.

   - 字符串 s 的后缀子串: 最后一个字符跟 s 对齐的子串

     字符串 s 的前缀子串: 起始字符跟 s 对齐的子串

   - 正确的滑动方式: 在好后缀的后缀子串中, 找与模式串前缀子串匹配的最长子串, 将模式串移动到与之对齐的位置.

3. 分别计算好后缀和坏字符规则下向后滑动的位数, 取其中最大的.



#### 代码实现

略



#### 性能分析及优化



### KMP 算法 (Knuth Morris Pratt)

#### 核心思想

- 与 KM 类似, 尽可能将模式串向后多滑动几位

- 好前缀规则



#### 复杂度分析

- 空间复杂度 O(m)
- 时间复杂度 O(n+m)





### 字典树 Trie

利用字符串之间的公共前缀, 将重复的前缀合并在一起



### AC 自动机

多模式匹配: 在主串中一次性查找多个模式串是否存在.



#### AC 自动机 (Aho-Corasick 算法)

##### 构建

1. 将多个模式串构建成 Trie 树;
2. 在 Trie 树上构建失败指针 (相当于 KMP 中的实现函数 next 数组)