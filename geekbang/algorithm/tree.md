### 概念

#### 节点

- 父节点, 子节点
- 兄弟节点: 父节点是同一个节点
- 根节点: 没有父节点
- 叶子节点: 没有子节点



#### 高度(height), 深度(depth), 层(level)

- 节点的高度: 节点到叶子节点的最长路径 (边数)
- 节点的深度: 根节点到这个节点所经历的边的个数
- 节点的层数: 节点的深度 + 1
- 树的高度: 根节点的高度



助记:

- 高度: 自底向上
- 深度: 自顶向下
- 层: 和深度类似但起点为 1



### 二叉树

- 满二叉树: 除了叶子节点, 其他节点都有左右两个子节点
- 完全二叉树: 
  - 叶子节点都在最下两层
  - 最后一层叶子节点都靠左排列
  - 除了最后一层, 其它层的节点个数都达到最大



#### 存储方式

- 链式存储法
- 顺序存储法, 基于数组
  - 用于存储完全二叉树, 最节省内存



#### 二叉树的遍历

- 前序遍历: 本身 -> 左子树 -> 右子树
- 中序遍历: 左子树 -> 本身 -> 右子树
- 后序遍历: 左子树 -> 右子树 -> 本身
- 时间复杂度 O(n)



### 二叉查找树 (Binary Search Tree, BST)

#### 概念

对树中任意一个节点

- 左子树中每个节点的值都小于这个节点的值
- 右子树中每个节点的值都大于这个节点的值



#### 二叉查找树的操作

1. 查找
2. 插入
3. 删除
   - 如果没有子节点, 重置其父节点指向该节点的指针
   - 如果只有一个子节点, 更新其父节点指向该节点的指针使其指向子节点
   - 有两个子节点, 将右子树中最小的节点替换到该节点位置
4. 其他
   - 查找最大节点, 最小节点, 前驱节点和后继节点
   - 中序遍历二叉查找树可以输出有序数据序列, 时间复杂度 O(n)



#### 支持重复数据的二叉查找树

- 用链表或支持动态扩容的数组存储节点数据
- 将重复的节点放到该节点的右子树, 视为大于这个节点的值
  - 插入时, 放入右子树
  - 查找时, 遇到值相同的节点, 不停止, 继续在右子树中查找, 直到遇到叶子节点
  - 删除时, 找到每个要删除的节点, 依次删除



#### 二叉查找树的时间复杂度

- 插入, 删除, 查找, 时间复杂度正比于树的高度

- 对于平衡二叉树, 时间复杂度是 O(logn)



#### 与散列表的对比

1. 输出有序数据时,

   - 散列表要先排序

   - 二叉树执行中序遍历, 时间复杂度 O(n)

2. 扩容

   - 散列表耗时多, 遇到散列冲突时, 性能不稳定
   - 平衡二叉查找树性能稳定

3. 操作时间复杂度

   - 散列表的时间复杂度虽然是常量级, 但是还要考虑 hash 冲突的情形, 以及 hash 函数的耗时, 所以工程实践中效率不一定高

4. 构造复杂程度

   - 散列表构造复杂
     - 散列函数
     - 冲突解决
     - 扩容
     - 缩容
   - 平衡二叉查找树
     - 平衡性, 且解决方案成熟, 固定

5. 空间开销

   - 散列表为了避免过多散列冲突, 装载因子不能太大





### 红黑树

二叉查找树的性能退化



#### 平衡二叉查找树

- 严格定义: 任意一个节点的左右子树的高度差不能大于 1
- 工程实践
  - 解决频繁插入, 删除操作下, 出现的时间复杂度退化
  - 让左右子树比较 "对称", "平衡"
  - 尽可能降低整棵树的高度, 使之不要比 $log_2n$ 大很多, 维持在对数量级



#### 红黑树定义

节点标记为红黑两类

1. 根节点是黑色的
2. 每个叶节点都是黑色的空节点 (NIL), 叶子节点不存储数据
3. 相邻节点不能同时为红色, 红色节点被黑色节点隔开
4. 每个节点, 到达其可达叶子节点的所有路径, 都包含相同数目黑色节点



#### 红黑树的"近似平衡"

"平衡" 等价为性能不退化

"近似平衡" 等价位性能不会退化的太严重



红黑树的高度近似 $2log_2n$



#### 红黑树的实践意义

- Treap, Splay Tree 无法完全避免性能退化
- AVL 树高度平衡, 但每次插入, 删除都要做调整, 开销比较大
- 红黑树维护平衡的成本比 AVL 树低, 各种操作性能稳定





### 实现红黑树

#### 基本思想

遇到不同节点排布, 对应的调整方式



- 平衡调整的意义: 维持红黑树特性的第三, 第四点

- 操作

  - 左旋: 围绕某个节点的左旋

    令目标节点为 X , 其右子节点为 Y

    - 将 X 的右子节点置为 Y 的左子节点

    - 将 Y 的左子节点置为 X, 
    - 用 Y 替换 X 原先的位置

  - 右旋

    令目标节点为 X, 其左子节点为 Y

    - 将 X 的左子节点置为 Y 的右子节点
    - 将 Y 的右子节点置为 X,
    - 用 Y 替换 X 原先的位置



#### 插入操作的平衡调整

红黑树规定:

- 插入的节点必须是红色
- 插入的节点都放在叶子节点上



插入操作情形

1. 父节点是红色, 不用做任何事
2. 插入节点是根节点, 直接改变颜色为黑色
3. 父节点是红色, 违背定义 3
   1. 如果关注节点是 a, 父节点是 b, 祖父节点是 c,  其叔叔节点 d 是红色, 依次执行
      - 将  b,  d 都置为黑色
      - 将 c 置为红色
      - 将 c 变成关注节点
      - 跳到 Case 2 或者 Case 3
   2. 如果关注节点是 a, 父节点是 b,  其叔叔节点 d 是黑色, a 是 b 的右子节点
      - 关注节点变成 b
      - 围绕关注节点左旋
      - 跳到 Case 3
   3. 如果关注节点是 a, 父节点是 b, 祖父节点是 c, 其叔叔节点 d 是黑色, a 是 b 的左子节点
      - 围绕 c 右旋
      - 将 b, c 颜色互换
      - 结束



#### 删除操作的平衡调整

(真复杂, 视为规则, 不问对错….)





### 堆

#### 定义

- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值
- 大顶堆, 小顶堆



#### 如何实现

##### 用数组存储堆

对于节点 i:

- 左子节点为 2i + 1
- 右子节点为 2i + 2
- 父节点为 (i-1) / 2



##### 往堆中插入元素

1. 将元素放到堆的最后

2. 按需调整, 使其满足堆的特性

   堆化 -> 从下往上堆化

   - 比较新插入节点和父节点的大小, 如果不满足堆特性, 则交换
   - 重复上一过程, 直到所有节点满足大小关系



##### 删除堆顶元素

- 将最后一个节点放到堆顶
- 比较父子节点, 互换不满足大小关系的节点
- 重复直到满足父子节点间大小关系 -> 从上往下的堆化方法



插入元素和删除堆顶元素的时间复杂度都是 O(logn)



#### 基于堆实现排序

基于大顶堆, 总数量 n

1. 建堆, 时间复杂度 O(n)

   原地建堆的思路:

   1. 以 [0, 1) 作为原始堆, 将后续元素不断插入堆中.
   2. 从第一个非叶子节点开始, 依次堆化

2. 排序

   1. 将堆顶元素跟最后一个元素交换
   2. 对 [0, n-1] 元素重新堆化
   3. 重复直到没有需要交换的堆顶元素



时间复杂度: 

建堆过程 O(n), 排序过程 O(nlogn), 整体 O(nlogn)



#### 与快速排序比较

1. 堆排序数据访问方式没有快速排序友好
2. 对于同样的数据, 堆排序算法的数据交换次数多于快速排序



### 堆的应用

#### 优先级队列



1. 合并有序小文件

   从 N 个有序文件中取出第一个字符串, 组成小顶堆, 移除堆顶, 追加到合并的目标文件, 然后在堆顶对应的文件中取出下一个字符串插入堆中

   重复直到完成.

2. 高性能定时器



#### 利用堆求 Top K

动态数据

1. 维护一个大小为 K 的小顶堆
2. 比较新元素与堆顶元素
   - 如果新元素较大, 删除堆顶元素, 插入新元素
   - 否则不处理



#### 利用堆求中位数(前 N / N%)

动态数据

- 一个大顶堆用于存储前 N 个数据, 一个小顶堆用于存储剩余数据
- 每次插入, 根据数据跟大顶堆和小顶堆堆顶数的差距决定插入的目标堆
- 校验两个堆内元素的分配情况, 移动数据直到满足分配比例或数量

